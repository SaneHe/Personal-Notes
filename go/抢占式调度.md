在 Go 语言中，协程（goroutine）调度器负责在多个线程上调度和运行协程。Go 1.14 及以后的版本中引入了 抢占式调度（preemptive scheduling），这使得 Go 运行时能够更高效地管理协程的执行，避免长时间运行的协程占用过多的 CPU 资源。以下是 Go 语言中协程可能被抢占调度的情况：

1. 系统调用（syscall）
当一个协程执行系统调用（例如文件 I/O、网络操作等）时，它可能会被阻塞。Go 运行时会将该协程从线程中移除，并将其放入一个等待队列，等待系统调用完成。一旦系统调用完成，Go 运行时会将该协程重新调度到可用的线程上。

2. 垃圾回收（Garbage Collection）
在 Go 中，垃圾回收过程可能会导致所有协程暂停（STW, Stop The World），以便安全地扫描和整理内存。当垃圾回收器需要执行时，所有协程都会被抢占，直到垃圾回收过程完成。

3. 栈增长（Stack Growth）
每个协程都有自己的栈空间，初始较小，但可以根据需要动态增长。如果协程需要的栈空间超过当前的分配，Go 运行时会暂停该协程，并为其分配更大的栈空间。这一过程中，协程会被抢占，直到栈增长操作完成。

4. 调度点（Preemption Checkpoints）
Go 1.14 引入了抢占式调度机制，增加了协程在执行过程中可以被抢占的检查点。常见的调度点包括函数调用、循环边界等。当协程运行到这些调度点时，Go 运行时会检查是否需要调度其他协程。若当前协程运行时间过长，可能会被抢占以运行其他协程。

5. 锁竞争（Lock Contention）
当多个协程竞争同一个锁时，无法获取锁的协程会被阻塞。Go 运行时会将这些阻塞的协程从运行队列中移除，并将它们放入一个等待队列中。当锁变为可用时，Go 运行时会重新调度其中一个等待的协程。

6. 手动调度（Manual Yielding）
尽管不是自动的抢占调度，开发者可以通过显式调用 runtime.Gosched() 来让出当前协程的执行权，允许其他协程执行。这种方式并不常用，但在某些情况下可以用来避免长时间运行的协程阻塞其他协程。

总结
Go 运行时的抢占式调度机制在多个场景下触发，以确保协程能够公平地使用 CPU 资源。这种机制大大减少了长时间运行的协程对系统资源的占用，提升了 Go 程序的并发性能和响应性。