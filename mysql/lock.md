## Mysql共享锁、排他锁、悲观锁、乐观锁及其使用场景

* 表级锁 -- 锁定整张表
* 页级锁 -- 锁定整页
* 行级锁 -- 锁定一行
* 共享锁 -- S锁 MyISAM 叫做读锁
* 排他锁 -- X锁 MyISAM 叫做写锁
* 悲观锁 -- 抽象性 实际不存在
* 乐观锁 -- 抽象性 实际不存在

## InnoDB 与 MyISAM

  - MyISAM 操作数据都是使用表级锁，即锁定整张表，性能低，并发不高；
  - InnoDB 支持事务，采用行级锁，即修改哪行数据，就可以只锁定哪行 (行级锁不是锁记录，而是锁定索引，先锁定非主键索引，再锁定主键索引)；
  - InnoDB 行锁是通过给索引项加锁实现的，如果没有索引，InnoDB 会通过隐藏的聚簇索引来对记录加锁。
    也就是说：如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。
    因为没有了索引，找到某一条记录就得扫描全表，要扫描全表，就得锁定表。

## 共享锁与排他锁
 
  - 数据库的增删改都默认会加排他锁，而查询也不会加任何锁。

> 共享锁：对某一资源加共享锁，自身、其他人都可以读取该资源（可以加多个共享锁），但是无法修改，必须等到共享锁释放完成；
> 语法为： `select * from table lock in share mode`

> 排他锁：对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作。
> 语法为： `select * from table for update`

## 乐观锁与悲观锁

  - 乐观锁和悲观锁都是针对读 `(select)` 来说的。

> 悲观锁： 悲观锁，正如其名，它指的是对数据被外界
> （包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，
> 因此，在整个数据处理过程中，将数据处于锁定状态。 
> 悲观锁的实现，往往依靠数据库提供的锁机制 
> （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）在数据库中，
> 
> 悲观锁的流程如下：
> 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
> 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 
> 具体响应方式由开发者根据实际需要决定。
> 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
> 
> 优点与不足：悲观并发控制实际上是“先取锁再访问”的保守策略，
> 为数据处理的安全提供了保证。但是在效率方面，
> 处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；
> 另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；
> 还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数

> 乐观锁： 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。
> 它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。
> 在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。
> 如果其他事务有更新的话，正在提交的事务会进行回滚。

> 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，
> 所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，
> 如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
> 数据版本,为数据增加的一个版本标识。
> 当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。
> 当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，
> 如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，
> 否则认为是过期数据。

>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳

> 优点与不足
> 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，
> 因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。
> 但如果直接简单这么做，还是有可能会遇到不可预期的结果，
> 例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。